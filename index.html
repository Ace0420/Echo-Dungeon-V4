<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Echo Dungeon V5</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #111;
        }
        #micButton {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #222;
            border: none;
            cursor: pointer;
            transition: background 0.3s;
        }
        #micButton:active {
            background: #444;
        }
        .listening {
            background: #004400 !important;
        }
        .start-button {
            background: #000044 !important;
        }
        #textDisplay {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
    </style>
</head>
<body>
    <div id="textDisplay" role="status" aria-live="polite"></div>
    <button id="micButton" class="start-button" onclick="handleClick()" aria-label="Voice command button - Tap to speak"></button>

    <script>
        const micButton = document.getElementById('micButton');
        const textDisplay = document.getElementById('textDisplay');

        function displayText(text) {
            textDisplay.innerHTML = text;
        }

        let browserSupport = {
            speechSynthesis: false,
            speechRecognition: false,
            https: false
        };

        function checkBrowserSupport() {
            browserSupport.https = window.location.protocol === 'https:' || window.location.hostname === 'localhost';
            browserSupport.speechSynthesis = !!(window.speechSynthesis && window.SpeechSynthesisUtterance);
            browserSupport.speechRecognition = !!(window.webkitSpeechRecognition || window.SpeechRecognition);
        }

        const game = {
            player: {
                class: '',
                level: 1,
                experience: 0,
                experienceToNext: 100,
                health: 100,
                maxHealth: 100,
                mana: 50,
                maxMana: 50,
                gold: 25,
                inventory: [],
                equippedRings: [],
                learnedAbilities: [],
                equippedAmulet: '',
                position: { x: 5, y: 5 },
                baseAttack: 15,
                defense: 0,
                weapon: '',
                armor: '',
                shield: ''
            },
            dungeon: {
                grid: {},
                size: 10,
                secretRoom: null,
                hasSecretRoom: false,
                currentLevel: 1 
            },
            currentRoom: null,
            combat: null,
            listening: false,
            started: false,
            needsClass: true,
            initialized: false,
            phase: 'init',
            merchantOpen: false
        };

        const classes = {
            warrior: {
                name: 'Warrior',
                health: 120,
                maxHealth: 120,
                mana: 30,
                maxMana: 30,
                gold: 50,
                items: ['Steel Sword', 'Health Potion', 'Health Potion', 'Chainmail', 'Iron Shield'],
                special: { name: 'Power Strike', damage: 40, cost: 15, type: 'damage' }
            },
            mage: { 
                name: 'Mage',
                health: 80,
                maxHealth: 80,
                mana: 100,
                maxMana: 100,
                gold: 75,
                items: ['Mystic Staff', 'Mana Potion', 'Health Potion', 'Enchanted Robes'],
                special: { name: 'Fireball', damage: 30, cost: 20, type: 'damage' } 
            },
            rogue: {
                name: 'Rogue',
                health: 100,
                maxHealth: 100,
                mana: 60,
                maxMana: 60,
                gold: 100,
                items: ['Shadow Daggers', 'Lockpicks', 'Health Potion', 'Shadow Leather'],
                special: { name: 'Backstab', damage: 35, cost: 25, type: 'damage' }
            }
        };

        const equipment = {
            weapons: [
                { name: 'Steel Sword', attack: 8, class: 'warrior', value: 100 },
                { name: 'Mystic Staff', attack: 10, class: 'mage', value: 150 },
                { name: 'Shadow Daggers', attack: 10, class: 'rogue', value: 120 },
                { name: 'Legendary Greatsword', attack: 15, class: 'warrior', value: 300 },
                { name: 'Archmage Staff', attack: 18, class: 'mage', value: 350 },
                { name: 'Vorpal Daggers', attack: 16, class: 'rogue', value: 320 },
                { name: 'Demon Slayer Blade', attack: 20, class: 'warrior', value: 500 },
                { name: 'Staff of the Cosmos', attack: 25, class: 'mage', value: 600 },
                { name: 'Ethereal Blades', attack: 22, class: 'rogue', value: 550 }
            ],
            armor: [
                { name: 'Chainmail', defense: 8, class: 'warrior', value: 100 },
                { name: 'Enchanted Robes', defense: 5, class: 'mage', value: 120 },
                { name: 'Shadow Leather', defense: 6, class: 'rogue', value: 110 },
                { name: 'Dragonscale Plate', defense: 15, class: 'warrior', value: 350 },
                { name: 'Arcane Vestments', defense: 12, class: 'mage', value: 380 },
                { name: 'Phantom Suit', defense: 13, class: 'rogue', value: 360 },
                { name: 'Titanium Fortress', defense: 22, class: 'warrior', value: 550 },
                { name: 'Celestial Robes', defense: 18, class: 'mage', value: 600 },
                { name: 'Void Cloak', defense: 20, class: 'rogue', value: 580 }
            ],
            shields: [
                { name: 'Iron Shield', defense: 5, class: 'warrior', value: 80 },
                { name: 'Tower Shield', defense: 10, class: 'warrior', value: 250 },
                { name: 'Aegis Shield', defense: 15, class: 'warrior', value: 450 }
            ]
        };

        const abilities = [
            { name: 'Icy Blast', damage: 25, cost: 25, type: 'freeze', description: 'Deals damage and freezes enemy for 1 turn', class: 'mage' },
            { name: 'Shield Bash', damage: 30, cost: 20, type: 'stun', description: 'Stun enemy for one turn', class: 'warrior' },
            { name: 'Poison Blade', damage: 20, cost: 20, type: 'poison', duration: 3, description: 'Poison damages per turn for 3 turns', class: 'rogue' },
            { name: 'Chain Lightning', damage: 45, cost: 30, type: 'chain', description: 'Lightning that chains to multiple enemies', class: 'mage' },
            { name: 'Arcane Missiles', damage: 22, cost: 18, type: 'damage', description: 'Multiple magic missiles', class: 'mage' },
            { name: 'Whirlwind', damage: 28, cost: 25, type: 'aoe', description: 'Spin attack hitting all enemies for full damage', class: 'warrior' },
            { name: 'Shadow Strike', damage: 32, cost: 22, type: 'damage', description: 'Strike from the shadows', class: 'rogue' },
            { name: 'Flurry of Strikes', damage: 18, cost: 25, type: 'flurry', description: '3 quick attacks across multiple enemies', class: 'rogue' }
        ];

        const amulets = [
            { name: 'Amulet of Vitality', effect: '+15 Max Health', stat: 'maxHealth', value: 15 },
            { name: 'Amulet of Mana', effect: '+15 Max Mana', stat: 'maxMana', value: 15 },
            { name: 'Amulet of Experience', effect: '+20% Experience Gain', stat: 'expGain', value: 1.2 },
            { name: 'Amulet of the Archmage', effect: '+30 Max Mana', stat: 'maxMana', value: 30 },
            { name: 'Amulet of the Titan', effect: '+30 Max Health', stat: 'maxHealth', value: 30 },
            { name: 'Amulet of Power', effect: '+5 Attack', stat: 'attack', value: 5 }
        ];
        const roomTypes = {
            entrance: { 
                descriptions: [
                    'the grand entrance hall. Torches flicker on ancient stone walls.',
                    'the entrance chamber. A faded tapestry hangs on the north wall.',
                    'the starting hall. Cobwebs drape from vaulted ceilings above.'
                ], 
                hasEnemy: false 
            },
            empty: { 
                descriptions: [
                    'an abandoned barracks. Rusty weapons litter the floor.',
                    'a collapsed library. Torn pages scatter at your feet.',
                    'a crumbling shrine. A broken altar stands in the center.',
                    'a forgotten armory. Empty weapon racks line the walls.',
                    'a dusty workshop. Ancient tools hang from hooks.',
                    'a meditation chamber. Stone benches circle a dry fountain.',
                    'an old prison cell. Iron bars have rusted through.',
                    'a guard post. A skeleton sits slumped in a chair.'
                ], 
                hasEnemy: false 
            },
            treasure: { 
                descriptions: [
                    'a glittering treasure vault. Gold coins reflect torchlight.',
                    'a dragon\'s hoard chamber. Piles of jewels gleam in the darkness.',
                    'a royal treasury. Ancient chests overflow with riches.',
                    'a pirate\'s cache. Stolen goods fill every corner.',
                    'a wizard\'s vault. Magical artifacts pulse with energy.'
                ], 
                hasEnemy: false 
            },
            enemy: { 
                descriptions: [
                    'a dark chamber. You sense hostile eyes watching you.',
                    'a blood-stained arena. Old battle scars mark the floor.',
                    'a shadowy lair. Something growls in the darkness.',
                    'a monster\'s den. Bones crunch beneath your feet.',
                    'a cursed chamber. An evil presence fills the air.'
                ], 
                hasEnemy: true 
            },
            boss: { 
                descriptions: [
                    'the throne room of darkness. A massive beast awaits on a stone throne.',
                    'the dragon\'s lair. Heat radiates from the enormous creature before you.',
                    'the demon king\'s chamber. Dark energy swirls around your foe.'
                ], 
                hasEnemy: true 
            },
            trap: { 
                descriptions: [
                    'a trapped corridor. Pressure plates cover the floor.',
                    'a spike-filled chamber. Deadly traps line the walls.',
                    'a poison gas room. Strange vapors seep from cracks.'
                ], 
                hasEnemy: false 
            },
            stairs: { 
                descriptions: [
                    'a spiral stairwell. Dark stone steps descend into deeper darkness.',
                    'a grand staircase. Ancient carvings decorate the descent.',
                    'a hidden passage. Secret stairs lead to the next level.'
                ], 
                hasEnemy: false 
            },
            fountain: {
                descriptions: [
                    'a magical fountain room. Crystal clear water bubbles from an enchanted spring.',
                    'an ancient healing shrine. A mystical fountain glows with restorative power.'
                ],
                hasEnemy: false
            },
            crypt: {
                descriptions: [
                    'a dusty crypt. Stone sarcophagi line the walls.',
                    'an ancient burial chamber. Skeletal remains rest in alcoves.',
                    'a forgotten tomb. Hieroglyphs cover every surface.'
                ],
                hasEnemy: false
            },
            merchant: {
                descriptions: [
                    'a merchant\'s tent. A hooded figure tends to various wares.',
                    'a traveling shop. Mysterious goods line makeshift shelves.'
                ],
                hasEnemy: false
            }
        };

        const enemies = {
            goblin: { name: 'Goblin', health: 30, damage: 8, gold: 5, exp: 15, fleeChance: 0.8 },
            skeleton: { name: 'Skeleton', health: 40, damage: 10, gold: 8, exp: 20, fleeChance: 0.7 },
            orc: { name: 'Orc', health: 60, damage: 15, gold: 12, exp: 30, fleeChance: 0.5 },
            wraith: { name: 'Wraith', health: 50, damage: 18, gold: 15, exp: 35, fleeChance: 0.6 },
            troll: { name: 'Troll', health: 80, damage: 20, gold: 20, exp: 45, fleeChance: 0.4, regenerate: 5 },
            dragon: { name: 'Dragon', health: 150, damage: 30, gold: 50, exp: 100, fleeChance: 0.1 },
            demon: { name: 'Demon', health: 120, damage: 28, gold: 45, exp: 80, fleeChance: 0.3 },
            vampire: { name: 'Vampire', health: 100, damage: 25, gold: 40, exp: 70, fleeChance: 0.4, regenerate: 8 },
            orcChieftain: { name: 'Orc Chieftain', health: 100, damage: 22, gold: 25, exp: 50, fleeChance: 0.3 },
            ancientWraith: { name: 'Ancient Wraith', health: 90, damage: 26, gold: 30, exp: 60, fleeChance: 0.4 },
            elderTroll: { name: 'Elder Troll', health: 150, damage: 28, gold: 40, exp: 75, fleeChance: 0.2, regenerate: 10 },
            archDemon: { name: 'Arch Demon', health: 180, damage: 35, gold: 70, exp: 120, fleeChance: 0.2 },
            hydra: { name: 'Hydra', health: 140, damage: 30, gold: 55, exp: 90, fleeChance: 0.3, regenerate: 12 },
            phoenixGuardian: { name: 'Phoenix Guardian', health: 130, damage: 32, gold: 60, exp: 95, fleeChance: 0.3, regenerate: 15 },
            lichKing: { name: 'Lich King', health: 160, damage: 38, gold: 80, exp: 130, fleeChance: 0.1, regenerate: 10 }
        };

        const treasures = [
            { name: 'Sapphire Gem', value: 50 },
            { name: 'Ruby Gem', value: 75 },
            { name: 'Diamond', value: 100 },
            { name: 'Emerald', value: 60 },
            { name: 'Ancient Coin Collection', value: 40 },
            { name: 'Golden Chalice', value: 80 },
            { name: 'Silver Crown', value: 90 },
            { name: 'Enchanted Amulet', value: 120 }
        ];

        const rings = [
            { name: 'Ring of Vitality', effect: '+10 Max Health', stat: 'maxHealth', value: 10 },
            { name: 'Ring of Minor Mana', effect: '+10 Max Mana', stat: 'maxMana', value: 10 },
            { name: 'Ring of Protection', effect: '+5 Max Health', stat: 'maxHealth', value: 5 },
            { name: 'Ring of Strength', effect: '+2 Attack Damage', stat: 'attack', value: 2 },
            { name: 'Ring of Wisdom', effect: '+5 Max Mana', stat: 'maxMana', value: 5 },
            { name: 'Ring of the Titan', effect: '+20 Max Health', stat: 'maxHealth', value: 20 },
            { name: 'Ring of Arcane Power', effect: '+15 Max Mana', stat: 'maxMana', value: 15 },
            { name: 'Ring of the Berserker', effect: '+4 Attack Damage', stat: 'attack', value: 4 }
        ];

        const merchantItems = [
            { name: 'Health Potion', type: 'potion', price: 30 },
            { name: 'Mana Potion', type: 'potion', price: 25 },
            { name: 'Greater Health Potion', type: 'potion', price: 60, healing: 80 },
            { name: 'Greater Mana Potion', type: 'potion', price: 50, mana: 60 }
        ];

        function speak(text, callback) {
            displayText(text);
            if (!browserSupport.speechSynthesis) {
                if (callback) setTimeout(callback, 2000);
                return;
            }
            try {
                speechSynthesis.cancel();
                setTimeout(() => {
                    const utterance = new SpeechSynthesisUtterance(text.replace(/<[^>]*>/g, ''));
                    utterance.rate = 0.9;
                    if (callback) {
                        utterance.onend = callback;
                        utterance.onerror = callback;
                    }
                    speechSynthesis.speak(utterance);
                }, 100);
            } catch (error) {
                if (callback) setTimeout(callback, 2000);
            }
        }

        function speakSequence(messages, callback) {
            if (messages.length === 0) {
                if (callback) callback();
                return;
            }
            const [first, ...rest] = messages;
            speak(first, () => {
                if (rest.length > 0) {
                    setTimeout(() => speakSequence(rest, callback), 500);
                } else if (callback) {
                    callback();
                }
            });
        }

        let recognition = null;

        function startListening() {
            if (!browserSupport.speechRecognition || !browserSupport.https) {
                speak('Voice recognition requires HTTPS and a compatible browser like Chrome or Edge.');
                return;
            }
            if (game.listening) { stopListening(); return; }
            try {
                const Recognition = window.webkitSpeechRecognition || window.SpeechRecognition;
                recognition = new Recognition();
                recognition.continuous = false;
                recognition.lang = 'en-US';
                recognition.onstart = () => {
                    game.listening = true;
                    micButton.classList.add('listening');
                };
                recognition.onresult = (event) => {
                    const command = event.results[0][0].transcript.toLowerCase().trim();
                    displayText(`You said: "${command}"`);
                    stopListening();
                    setTimeout(() => processCommand(command), 500);
                };
                recognition.onerror = (event) => {
                    stopListening();
                    if (event.error !== 'no-speech' && event.error !== 'aborted') {
                        speak('Voice error. Try again.');
                    }
                };
                recognition.onend = () => stopListening();
                recognition.start();
            } catch (error) {
                speak('Failed to start voice recognition.');
                stopListening();
            }
        }

        function stopListening() {
            game.listening = false;
            micButton.classList.remove('listening');
            if (recognition) {
                try { recognition.stop(); } catch (e) {}
                recognition = null;
            }
        }

        function saveGame() {
            const saveData = {
                player: game.player,
                dungeon: {
                    grid: game.dungeon.grid,
                    currentLevel: game.dungeon.currentLevel,
                    size: game.dungeon.size,
                    hasSecretRoom: game.dungeon.hasSecretRoom
                }
            };
            const saveStr = JSON.stringify(saveData);
            const pin = Math.floor(1000 + Math.random() * 9000).toString();
            const key = `echoDungeon_${pin}`;
            const data = { save: saveStr, timestamp: Date.now() };
            sessionStorage.setItem(key, JSON.stringify(data));
            const spokenPin = pin.split('').join(' ');
            speak(`Game saved! Your save PIN is ${spokenPin}. Say "load game" then "code ${spokenPin}" to load.`);
        }

        function loadGame(pin) {
            try {
                const key = `echoDungeon_${pin}`;
                const dataStr = sessionStorage.getItem(key);
                if (!dataStr) {
                    speak(`No game found for PIN ${pin.split('').join(' ')}. Try another PIN or start a new game.`);
                    return;
                }
                const data = JSON.parse(dataStr);
                const saveData = JSON.parse(data.save);
                game.player = saveData.player;
                game.dungeon.grid = saveData.dungeon.grid;
                game.dungeon.currentLevel = saveData.dungeon.currentLevel;
                game.dungeon.size = saveData.dungeon.size;
                game.dungeon.hasSecretRoom = saveData.dungeon.hasSecretRoom;
                const posKey = `${game.player.position.x},${game.player.position.y}`;
                game.currentRoom = game.dungeon.grid[posKey];
                game.initialized = true;
                game.started = true;
                game.needsClass = false;
                game.phase = 'exploration';
                micButton.classList.remove('start-button');
                speak(`Game loaded! You are a level ${game.player.level} ${classes[game.player.class].name} on Dungeon Level ${game.dungeon.currentLevel}.`, () => {
                    describeRoom();
                });
            } catch (e) {
                speak('Error loading game. The PIN may be incorrect.');
            }
        }

        function initializeGame() {
            game.initialized = true;
            micButton.classList.remove('start-button');
            speak("Welcome to Echo Dungeon V5, Lisa! Say 'load game' and provide your save PIN, or choose your class: warrior, mage, or rogue."); 
        }

        function handleClick() {
            if (!game.initialized) {
                initializeGame();
            } else {
                startListening();
            }
        }
        
        function processCommand(command) {
            if (command.includes('save game') || command.includes('save')) { 
                saveGame(); 
                return; 
            }
            
            if (command.includes('load game') || command.includes('load')) {
                speak('Please say your save PIN after the word "code".');
                game.phase = 'loading';
                return;
            }
            
            if (command.includes('code ') && game.phase === 'loading') {
                const pin = command.split('code ')[1].trim().replace(/\s/g, '');
                loadGame(pin);
                return;
            }

            if (game.merchantOpen) {
                if (command.
                    messages.push(`Strike 3 hits ${game.combat.enemy.name} for ${hit3} damage!`);
                );
                    
                    if (availableAbilities.length > 0) {
                        const ability = availableAbilities[Math.floor(Math.random() * availableAbilities.length)];
                        game.player.inventory.push(ability.name);
                        messages.push(`A ${ability.name} book! Say "read book" to learn it.`);
                    }
                }
                
                if (messages.length === 1) { messages.push('Nothing of value.'); }

                speakSequence(messages);
            }
        }

        function meditate() {
            if (game.combat) {
                speak('You cannot meditate during combat!');
                return;
            }
            const manaRestored = 15;
            const previousMana = game.player.mana;
            
            if (game.player.mana === game.player.maxMana) {
                speak('You are already at full mana.');
                return;
            }

            game.player.mana = Math.min(game.player.maxMana, game.player.mana + manaRestored);
            const actualRestored = game.player.mana - previousMana;

            speak(`You meditate and restore ${actualRestored} mana. Current mana: ${game.player.mana}.`);
        }

        function startCombat(enemy, secondEnemy = null) {
            game.combat = { 
                enemy: { ...enemy }, 
                secondEnemy: secondEnemy ? { ...secondEnemy } : null,
                playerDefending: false 
            };
            game.phase = 'combat';
            
            let messages = [`Combat begins!`, `${enemy.name} has ${enemy.health} health.`];
            
            if (secondEnemy) {
                messages.push(`${secondEnemy.name} has ${secondEnemy.health} health.`);
                messages.push(`You face two enemies!`);
            }
            
            if (enemy.regenerate) {
                messages.push(`Warning: ${enemy.name} regenerates ${enemy.regenerate} health per turn!`);
            }
            if (secondEnemy && secondEnemy.regenerate) {
                messages.push(`Warning: ${secondEnemy.name} regenerates ${secondEnemy.regenerate} health per turn!`);
            }
            
            messages.push(`What will you do? Attack, defend, special, cast spell, use potion, or flee.`);
            
            speakSequence(messages);
        }
        
        function processPotionCommand(command) {
            let potionType = null;
            
            if (command.includes('greater health')) {
                potionType = 'Greater Health Potion';
            } else if (command.includes('greater mana')) {
                potionType = 'Greater Mana Potion';
            } else if (command.includes('health') || command.includes('heal')) {
                potionType = 'Health Potion';
            } else if (command.includes('mana')) {
                potionType = 'Mana Potion';
            }
            
            if (!potionType) {
                const healthIdx = game.player.inventory.indexOf('Health Potion');
                const manaIdx = game.player.inventory.indexOf('Mana Potion');
                
                if (healthIdx !== -1 && game.player.health < game.player.maxHealth) {
                    potionType = 'Health Potion';
                } else if (manaIdx !== -1 && game.player.mana < game.player.maxMana) {
                    potionType = 'Mana Potion';
                } else if (healthIdx !== -1) {
                    potionType = 'Health Potion';
                } else if (manaIdx !== -1) {
                    potionType = 'Mana Potion';
                }
            }
            
            if (potionType) {
                usePotion(potionType);
            } else {
                speak('You have no potions.');
            }
        }

        function playerAttack() {
            const weaponData = equipment.weapons.find(w => w.name === game.player.weapon);
            const weaponAttack = weaponData ? weaponData.attack : 0;
            
            let amuletBonus = 0;
            if (game.player.equippedAmulet) {
                const amuletData = amulets.find(a => a.name === game.player.equippedAmulet);
                if (amuletData && amuletData.stat === 'attack') {
                    amuletBonus = amuletData.value;
                }
            }
            
            let baseDamage = game.player.baseAttack + weaponAttack + amuletBonus;
            
            if (game.player.class === 'warrior' || game.player.class === 'rogue') {
                baseDamage += (game.player.level - 1) * 5;
            }
            
            const ringBonus = game.player.equippedRings.reduce((total, ring) => {
                const ringData = rings.find(r => r.name === ring);
                return total + (ringData && ringData.stat === 'attack' ? ringData.value : 0);
            }, 0);
            
            const damage = baseDamage + ringBonus + Math.floor(Math.random() * 10);
            
            let targetEnemy = game.combat.enemy;
            if (game.combat.secondEnemy && game.combat.secondEnemy.health > 0 && Math.random() < 0.5) {
                targetEnemy = game.combat.secondEnemy;
            }
            
            targetEnemy.health -= damage;
            
            const enemyName = targetEnemy === game.combat.enemy ? game.combat.enemy.name : game.combat.secondEnemy.name;
            
            speakSequence([
                `You attack ${enemyName} for ${damage} damage!`,
                `${enemyName} has ${Math.max(0, targetEnemy.health)} health left.`
            ], () => {
                if (game.combat.enemy.health <= 0 && (!game.combat.secondEnemy || game.combat.secondEnemy.health <= 0)) {
                    setTimeout(() => combatVictory(), 1000);
                } else if (game.combat.enemy.health <= 0 && game.combat.secondEnemy && game.combat.secondEnemy.health > 0) {
                    game.combat.enemy = game.combat.secondEnemy;
                    game.combat.secondEnemy = null;
                    speak(`${game.combat.enemy.name} remains! Health: ${game.combat.enemy.health}.`, () => {
                        setTimeout(() => enemyTurn(), 1000);
                    });
                } else if (game.combat.secondEnemy && game.combat.secondEnemy.health <= 0) {
                    game.combat.secondEnemy = null;
                    speak(`${game.combat.enemy.name} stands alone! Health: ${game.combat.enemy.health}.`, () => {
                        setTimeout(() => enemyTurn(), 1000);
                    });
                } else {
                    setTimeout(() => enemyTurn(), 1000);
                }
            });
        }

        function playerDefend() {
            game.combat.playerDefending = true;
            speak('You brace for impact.', () => {
                setTimeout(() => enemyTurn(), 1000);
            });
        }

        function playerSpecial() {
            const classData = classes[game.player.class];
            const special = classData.special;
            
            if (game.player.mana < special.cost) {
                speak(`Not enough mana. You need ${special.cost}.`);
                return;
            }
            
            game.player.mana -= special.cost;
            
            if (special.type === 'damage') {
                let damage = special.damage;
                
                if (game.player.class === 'warrior' || game.player.class === 'rogue') {
                    damage += (game.player.level - 1) * 5;
                } else if (game.player.class === 'mage') {
                    damage += (game.player.level - 1) * 6;
                }
                
                game.combat.enemy.health -= damage;
                
                speakSequence([
                    `You unleash ${special.name}!`,
                    `${damage} damage!`,
                    `${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health left.`
                ], () => {
                    if (game.combat.enemy.health <= 0) {
                        if (game.combat.secondEnemy && game.combat.secondEnemy.health > 0) {
                            game.combat.enemy = game.combat.secondEnemy;
                            game.combat.secondEnemy = null;
                            speak(`${game.combat.enemy.name} remains! Health: ${game.combat.enemy.health}.`, () => {
                                setTimeout(() => enemyTurn(), 1000);
                            });
                        } else {
                            setTimeout(() => combatVictory(), 1000);
                        }
                    } else {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            }
        }

        function usePotion(potionType) {
            const idx = game.player.inventory.indexOf(potionType);
            if (idx === -1) {
                speak(`You do not have a ${potionType}.`);
                return;
            }
            
            game.player.inventory.splice(idx, 1);
            
            if (potionType === 'Health Potion') {
                const heal = 40;
                const oldHealth = game.player.health;
                game.player.health = Math.min(game.player.maxHealth, game.player.health + heal);
                const actualHeal = game.player.health - oldHealth;
                speak(`You drink a health potion and restore ${actualHeal} health. Health: ${game.player.health}.`, () => {
                    if (game.combat) {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (potionType === 'Greater Health Potion') {
                const heal = 80;
                const oldHealth = game.player.health;
                game.player.health = Math.min(game.player.maxHealth, game.player.health + heal);
                const actualHeal = game.player.health - oldHealth;
                speak(`You drink a greater health potion and restore ${actualHeal} health. Health: ${game.player.health}.`, () => {
                    if (game.combat) {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (potionType === 'Mana Potion') {
                const restore = 30;
                const oldMana = game.player.mana;
                game.player.mana = Math.min(game.player.maxMana, game.player.mana + restore);
                const actualRestore = game.player.mana - oldMana;
                speak(`You drink a mana potion and restore ${actualRestore} mana. Mana: ${game.player.mana}.`, () => {
                    if (game.combat) {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            } else if (potionType === 'Greater Mana Potion') {
                const restore = 60;
                const oldMana = game.player.mana;
                game.player.mana = Math.min(game.player.maxMana, game.player.mana + restore);
                const actualRestore = game.player.mana - oldMana;
                speak(`You drink a greater mana potion and restore ${actualRestore} mana. Mana: ${game.player.mana}.`, () => {
                    if (game.combat) {
                        setTimeout(() => enemyTurn(), 1000);
                    }
                });
            }
        }

        function attemptFlee() {
            const chance = game.combat.enemy.fleeChance;
            const roll = Math.random();
            
            speak(`Attempting to flee...`, () => {
                setTimeout(() => {
                    if (roll < chance) {
                        speak('You successfully escape!', () => {
                            game.combat = null;
                            game.phase = 'exploration';
                            setTimeout(() => {
                                const centerX = 5;
                                const centerY = 5;
                                game.player.position = { x: centerX, y: centerY };
                                const key = `${centerX},${centerY}`;
                                game.currentRoom = game.dungeon.grid[key];
                                speak('You flee back to the entrance.');
                            }, 1000);
                        });
                    } else {
                        speak('You fail to escape!', () => {
                            setTimeout(() => enemyTurn(), 1000);
                        });
                    }
                }, 1000);
            });
        }

        function enemyTurn() {
            let messages = [];
            
            if (game.combat.enemy.frozen) {
                messages.push(`${game.combat.enemy.name} is frozen and cannot act!`);
                game.combat.enemy.frozen = false;
            } else if (game.combat.enemy.stunned) {
                messages.push(`${game.combat.enemy.name} is stunned and cannot act!`);
                game.combat.enemy.stunned = false;
            } else {
                if (game.combat.enemy.regenerate) {
                    game.combat.enemy.health += game.combat.enemy.regenerate;
                    messages.push(`${game.combat.enemy.name} regenerates ${game.combat.enemy.regenerate} health!`);
                }
                
                if (game.combat.enemy.poisoned) {
                    game.combat.enemy.health -= game.combat.enemy.poisoned.damage;
                    messages.push(`${game.combat.enemy.name} takes ${game.combat.enemy.poisoned.damage} poison damage!`);
                    game.combat.enemy.poisoned.duration--;
                    if (game.combat.enemy.poisoned.duration <= 0) {
                        game.combat.enemy.poisoned = null;
                    }
                    if (game.combat.enemy.health <= 0) {
                        speakSequence(messages, () => {
                            setTimeout(() => {
                                if (game.combat.secondEnemy && game.combat.secondEnemy.health > 0) {
                                    game.combat.enemy = game.combat.secondEnemy;
                                    game.combat.secondEnemy = null;
                                    speak(`${game.combat.enemy.name} remains! Health: ${game.combat.enemy.health}.`);
                                } else {
                                    combatVictory();
                                }
                            }, 1000);
                        });
                        return;
                    }
                }
                
                let damage = game.combat.enemy.damage;
                
                if (game.combat.playerDefending) {
                    damage = Math.floor(damage * 0.5);
                    game.combat.playerDefending = false;
                }
                
                const evadeChance = game.player.class === 'rogue' ? 0.15 + (game.player.level * 0.01) : 0;
                const evaded = Math.random() < evadeChance;
                
                if (evaded) {
                    messages.push(`${game.combat.enemy.name} attacks but you evade!`);
                    
                    const counterDamage = Math.floor(game.player.baseAttack * 0.75);
                    game.combat.enemy.health -= counterDamage;
                    messages.push(`You counter-attack for ${counterDamage} damage!`);
                    messages.push(`${game.combat.enemy.name} has ${Math.max(0, game.combat.enemy.health)} health.`);
                } else {
                    const reducedDamage = Math.max(1, damage - game.player.defense);
                    game.player.health -= reducedDamage;
                    messages.push(`${game.combat.enemy.name} attacks for ${reducedDamage} damage!`);
                }
            }
            
            if (game.combat.secondEnemy && game.combat.secondEnemy.health > 0) {
                if (game.combat.secondEnemy.regenerate) {
                    game.combat.secondEnemy.health += game.combat.secondEnemy.regenerate;
                    messages.push(`${game.combat.secondEnemy.name} regenerates ${game.combat.secondEnemy.regenerate} health!`);
                }
                
                let damage2 = game.combat.secondEnemy.damage;
                
                const evadeChance2 = game.player.class === 'rogue' ? 0.15 + (game.player.level * 0.01) : 0;
                const evaded2 = Math.random() < evadeChance2;
                
                if (evaded2) {
                    messages.push(`${game.combat.secondEnemy.name} attacks but you evade!`);
                    
                    const counterDamage2 = Math.floor(game.player.baseAttack * 0.75);
                    game.combat.secondEnemy.health -= counterDamage2;
                    messages.push(`You counter-attack for ${counterDamage2} damage!`);
                    messages.push(`${game.combat.secondEnemy.name} has ${Math.max(0, game.combat.secondEnemy.health)} health.`);
                } else {
                    const reducedDamage2 = Math.max(1, damage2 - game.player.defense);
                    game.player.health -= reducedDamage2;
                    messages.push(`${game.combat.secondEnemy.name} attacks for ${reducedDamage2} damage!`);
                }
            }
            
            messages.push(`Your health: ${Math.max(0, game.player.health)}.`);
            
            speakSequence(messages, () => {
                if (game.player.health <= 0) {
                    setTimeout(() => gameOver(), 1000);
                } else if (game.combat.enemy.health <= 0 && (!game.combat.secondEnemy || game.combat.secondEnemy.health <= 0)) {
                    setTimeout(() => combatVictory(), 1000);
                } else if (game.combat.enemy.health <= 0 && game.combat.secondEnemy && game.combat.secondEnemy.health > 0) {
                    game.combat.enemy = game.combat.secondEnemy;
                    game.combat.secondEnemy = null;
                    speak(`${game.combat.enemy.name} remains! Health: ${game.combat.enemy.health}.`, () => {
                        setTimeout(() => speak('What will you do?'), 500);
                    });
                } else if (game.combat.secondEnemy && game.combat.secondEnemy.health <= 0) {
                    game.combat.secondEnemy = null;
                    speak(`${game.combat.enemy.name} stands alone! Health: ${game.combat.enemy.health}.`, () => {
                        setTimeout(() => speak('What will you do?'), 500);
                    });
                } else {
                    setTimeout(() => speak('What will you do?'), 500);
                }
            });
        }

        function combatVictory() {
            const gold = game.combat.enemy.gold;
            const exp = game.combat.enemy.exp;
            game.player.gold += gold;
            
            if (game.currentRoom.enemy) {
                game.currentRoom.enemy.health = 0;
            }
            if (game.currentRoom.secondEnemy) {
                game.currentRoom.secondEnemy.health = 0;
            }
            
            speakSequence([
                `${game.combat.enemy.name} defeated!`,
                `You gain ${gold} gold and ${exp} experience!`
            ], () => {
                game.combat = null;
                game.phase = 'exploration';
                gainExperience(exp);
                
                if (game.currentRoom.type === 'boss') {
                    setTimeout(() => dungeonComplete(), 1500);
                } else {
                    setTimeout(() => speak('What will you do next?'), 1000);
                }
            });
        }

        function dungeonComplete() {
            speakSequence([
                'You defeated the boss!',
                'The dungeon level is cleared!',
                'Seek the stairs to descend deeper!',
                `You are now level ${game.player.level} with ${game.player.gold} gold.`
            ]);
        }

        function gameOver() {
            speakSequence([
                'You have been defeated.',
                'Your adventure ends here.',
                `You reached level ${game.player.level} and collected ${game.player.gold} gold.`,
                'Game over. Refresh to play again.'
            ]);
        }

        function characterStatus() {
            const classData = classes[game.player.class];
            const special = classData.special;
            const specialInfo = special.type === 'damage' ? `Deals ${special.damage} damage.` : `Restores ${special.heal} health.`;
            const expNeeded = game.player.experienceToNext - game.player.experience;

            let messages = [
                `Level ${game.player.level} ${classData.name}.`,
                `Health: ${game.player.health} of ${game.player.maxHealth}.`,
                `Mana: ${game.player.mana} of ${game.player.maxMana}.`,
                `Attack: ${game.player.baseAttack}. Defense: ${game.player.defense}.`,
                `Experience: ${game.player.experience}. Need ${expNeeded} for next level.`,
                `Special ability: ${special.name}. Costs ${special.cost} mana. ${specialInfo}`,
                `Gold: ${game.player.gold}.`,
            ];

            if (game.player.learnedAbilities.length > 0) {
                messages.push(`Learned abilities: ${game.player.learnedAbilities.join(', ')}.`);
            }

            if (game.player.equippedRings.length > 0) {
                messages.push(`Equipped rings: ${game.player.equippedRings.join(', ')}.`);
            } else {
                messages.push(`No rings equipped.`);
            }

            if (game.player.equippedAmulet) {
                messages.push(`Equipped amulet: ${game.player.equippedAmulet}.`);
            } else {
                messages.push(`No amulet equipped.`);
            }

            speakSequence(messages);
        }

        function listInventory() {
            if (game.player.inventory.length === 0 && game.player.equippedRings.length === 0) {
                speak(`Empty inventory. Gold: ${game.player.gold}.`);
            } else {
                const healthPotions = game.player.inventory.filter(i => i === 'Health Potion').length;
                const greaterHealthPotions = game.player.inventory.filter(i => i === 'Greater Health Potion').length;
                const manaPotions = game.player.inventory.filter(i => i === 'Mana Potion').length;
                const greaterManaPotions = game.player.inventory.filter(i => i === 'Greater Mana Potion').length;
                
                const ringsList = game.player.inventory.filter(i => rings.some(r => r.name === i));
                const ringCounts = {};
                ringsList.forEach(ring => {
                    ringCounts[ring] = (ringCounts[ring] || 0) + 1;
                });
                
                const amuletsList = game.player.inventory.filter(i => amulets.some(a => a.name === i));
                const amuletCounts = {};
                amuletsList.forEach(amulet => {
                    amuletCounts[amulet] = (amuletCounts[amulet] || 0) + 1;
                });
                
                const abilityBooks = game.player.inventory.filter(i => abilities.some(a => a.name === i));
                const otherItems = game.player.inventory.filter(i => 
                    i !== 'Health Potion' && 
                    i !== 'Greater Health Potion' &&
                    i !== 'Mana Potion' && 
                    i !== 'Greater Mana Potion' &&
                    !ringsList.includes(i) && 
                    !amuletsList.includes(i) &&
                    !abilityBooks.includes(i)
                );
                
                const messages = ['Inventory:'];
                if (healthPotions > 0) messages.push(`${healthPotions} health potion${healthPotions > 1 ? 's' : ''}.`);
                if (greaterHealthPotions > 0) messages.push(`${greaterHealthPotions} greater health potion${greaterHealthPotions > 1 ? 's' : ''}.`);
                if (manaPotions > 0) messages.push(`${manaPotions} mana potion${manaPotions > 1 ? 's' : ''}.`);
                if (greaterManaPotions > 0) messages.push(`${greaterManaPotions} greater mana potion${greaterManaPotions > 1 ? 's' : ''}.`);
                if (abilityBooks.length > 0) messages.push(`Unread books: ${abilityBooks.join(', ')}.`);
                
                const unequippedRingsList = Object.entries(ringCounts).map(([ring, count]) => 
                    count > 1 ? `${ring} x${count}` : ring
                );
                if (unequippedRingsList.length > 0) messages.push(`Unequipped rings: ${unequippedRingsList.join(', ')}.`);
                
                if (game.player.equippedRings.length > 0) {
                    messages.push(`Equipped rings: ${game.player.equippedRings.join(', ')}.`);
                }
                
                const unequippedAmuletsList = Object.entries(amuletCounts).map(([amulet, count]) => 
                    count > 1 ? `${amulet} x${count}` : amulet
                );
                if (unequippedAmuletsList.length > 0) messages.push(`Unequipped amulets: ${unequippedAmuletsList.join(', ')}.`);
                
                if (game.player.equippedAmulet) messages.push(`Equipped amulet: ${game.player.equippedAmulet}.`);
                if (otherItems.length > 0) messages.push(`Equipment: ${otherItems.join(', ')}.`);
                messages.push(`Gold: ${game.player.gold}.`);
                
                speakSequence(messages);
            }
        }

        function showHelp() {
            if (game.phase === 'combat') {
                speak('Combat commands: attack, defend, special, cast spell, use potion, or flee.');
            } else {
                speak('Exploration commands: north, south, east, west, look around, search, open chest, drink fountain, merchant, meditate, wear ring, equip amulet, read book, use potion, status, inventory, save game, or load game.');
            }
        }

        function listCommands() {
            if (game.phase === 'combat') {
                speakSequence([
                    'Combat commands:',
                    'Attack. Deal damage.',
                    'Defend. Reduce incoming damage.',
                    'Special. Use your class ability.',
                    'Cast spell. Use a learned ability.',
                    'Use potion. Heal or restore mana.',
                    'Flee. Try to escape.'
                ]);
            } else {
                speakSequence([
                    'Movement: north, south, east, west, go down stairs.',
                    'Actions: look around, search, open chest, drink fountain, merchant, meditate, wear ring, equip amulet, read book, use potion.',
                    'Info: status, inventory, hint.',
                    'System: save game, load game, commands, help.'
                ]);
            }
        }

        function giveHint() {
            if (game.phase === 'combat') {
                if (game.player.health < 30) {
                    speak('Your health is low. Consider using a health potion or defending.');
                } else if (game.player.mana >= classes[game.player.class].special.cost) {
                    speak(`You have enough mana for ${classes[game.player.class].special.name}.`);
                } else {
                    speak('Try attacking or defending based on your health.');
                }
            } else {
                const room = game.currentRoom;
                if (room.type === 'stairs') {
                    speak('A staircase is here. Say "go down stairs" to descend to the next level.');
                } else if (room.type === 'merchant') {
                    speak('A merchant is here. Say "merchant" to trade goods.');
                } else if (room.type === 'fountain' && !room.fountainUsed) {
                    speak('There is a magical fountain here. Say "drink fountain" for full healing.');
                } else if (room.hasChest && !room.searched) {
                    speak('There is a chest here. Say open chest.');
                } else if (!room.searched) {
                    speak('You have not searched this room yet. Try searching.');
                } else if (game.player.mana < game.player.maxMana * 0.5) {
                    speak('Your mana is low. Consider saying meditate to recover.');
                } else if (room.type === 'boss') {
                    speak('This is a boss room. Be prepared for a tough fight.');
                } else {
                    speak('Explore in different directions. The boss is at the far south east corner. Look for merchants to buy potions and sell loot.');
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            checkBrowserSupport();
            setTimeout(() => {
                speak('Echo Dungeon V5 is ready, Lisa! Tap the screen to begin.');
            }, 1000);
        });

        micButton.addEventListener('contextmenu', (e) => e.preventDefault());
    </script>
</body>
</html>
